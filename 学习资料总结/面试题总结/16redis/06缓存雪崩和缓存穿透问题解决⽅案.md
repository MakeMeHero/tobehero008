###缓存雪崩？

简介：缓存同⼀时间⼤⾯积的失效，所以，后⾯的请求都会落到数据库上，造成数据库短时间内承受⼤ 量请求⽽崩掉。 

有哪些解决办法？ 

事前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策 略。 

事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉 

事后：利⽤ redis 持久化机制保存的数据尽快恢复缓存 



###缓存穿透 

缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有 经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的 key 发起⼤量请求，导致⼤量请 求落到数据库。 

⼀般MySQL 默认的最⼤连接数在 150 左右，这个可以通过 show variables like '%max_connections%'; 命令来查看。最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹络等 ⽆⼒条件都是其运⾏指标，这些指标都会限制其并发能⼒！所以，⼀般 3000 个并发请求就能打死⼤部 分数据库了。 

有哪些解决办法？ 

最基本的就是⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的 数据库 id 不能⼩于 0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。 

1）缓存⽆效 key : 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设置过期时 间，具体命令如下： SET key value EX 10086 。这种⽅式可以解决请求的 key 变化不频繁的情 况，如果⿊客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存⼤量⽆效的 key 。很明显， 这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key 的过期时间设置短⼀点⽐如 1 分钟。 

2）布隆过滤器：布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断⼀个给定数 据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要 找的那个“⼈”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当⽤户请求过 来，我会先判断⽤户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信 息给客户端，存在的话才会⾛下⾯的流程 