### Serial收集器 

Serial（串⾏）收集器收集器是最基本、历史最悠久的垃圾收集器了。⼤家看名字就知道这个收集器是 ⼀个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使⽤⼀条垃圾收集线程去完成垃圾收 集⼯作，更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程（ "Stop The World" ），直到它收集结束。 

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法 

![](E:\学习资料总结\面试题总结\17JVM\assets/QQ截图20201225230146.png)

虚拟机的设计者们当然知道Stop The World带来的不良⽤户体验，所以在后续的垃圾收集器设计中停顿 时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 

但是Serial收集器有没有优于其他垃圾收集器的地⽅呢？当然有，它简单⽽⾼效（与其他收集器的单线 程相⽐）。Serial收集器由于没有线程交互的开销，⾃然可以获得很⾼的单线程收集效率。Serial收集 器对于运⾏在Client模式下的虚拟机来说是个不错的选择。 

### ParNew收集器 

ParNew收集器其实就是Serial收集器的多线程版本，除了使⽤多线程进⾏垃圾收集外，其余⾏为（控制 参数、收集算法、回收策略等等）和Serial收集器完全⼀样。 

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。 

![](E:\学习资料总结\面试题总结\17JVM\assets/QQ截图20201225230234.png)

它是许多运⾏在Server模式下的虚拟机的⾸要选择，除了Serial收集器外，只有它能与CMS收集器（真 正意义上的并发收集器，后⾯会介绍到）配合⼯作。 

### Parallel Scavenge收集器 

Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是 ⽤户线程的停顿时间（提⾼⽤户体验）。所谓吞吐量就是CPU中⽤于运⾏⽤户代码的时间与CPU总消耗时 间的⽐值。 Parallel Scavenge收集器提供了很多参数供⽤户找到最合适的停顿时间或最⼤吞吐量，如 果对于收集器运作不太了解的话，⼿⼯优化存在的话可以选择把内存管理优化交给虚拟机去完成也是⼀ 个不错的选择。 

新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。 

![](E:\学习资料总结\面试题总结\17JVM\assets/QQ截图20201225230325.png)

### Serial Old收集器

 Serial收集器的⽼年代版本，它同样是⼀个单线程收集器。它主要有两⼤⽤途：⼀种⽤途是在JDK1.5以 及以前的版本中与Parallel Scavenge收集器搭配使⽤，另⼀种⽤途是作为CMS收集器的后备⽅案。 

### Parallel Old收集器

 Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。在注重吞吐量以及CPU资源 的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 

### CMS收集器 

CMS（Concurrent Mark Sweep）收集器是⼀种以获取最短回收停顿时间为⽬标的收集器。它⽽⾮常符合 在注重⽤户体验的应⽤上使⽤。

 CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第⼀款真正意义上的并发收集器，它第⼀次实 现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。 

从名字中的Mark Sweep这两个词可以看出，CMS收集器是⼀种 “标记-清除”算法实现的，它的运作过程 相⽐于前⾯⼏种垃圾收集器来说更加复杂⼀些。整个过程分为四个步骤： 

初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；

 并发标记： 同时开启GC和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这 个闭包结构并不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以 GC线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。 

重新标记： 重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变 动的那⼀部分对象的标记记录，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐ 并发标记阶段时间短 

并发清除： 开启⽤户线程，同时GC线程开始对为标记的区域做清扫。 

![](E:\学习资料总结\面试题总结\17JVM\assets/QQ截图20201225230510.png)

从它的名字就可以看出它是⼀款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下⾯三个 明显的缺点： 

对CPU资源敏感； ⽆法处理浮动垃圾； 它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。 

### G1收集器 

G1 (Garbage-First)是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器. 以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征. 

被视为JDK1.7中HotSpot虚拟机的⼀个重要进化特征。它具备⼀下特点： 

并⾏与并发：G1能充分利⽤CPU、多核环境下的硬件优势，使⽤多个CPU（CPU或者CPU核⼼）来缩 短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执⾏的GC动作，G1收集器仍 然可以通过并发的⽅式让java程序继续执⾏。 

分代收集：虽然G1可以不需要其他收集器配合就能独⽴管理整个GC堆，但是还是保留了分代的概 念。

 空间整合：与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集 器；从局部上来看是基于“复制”算法实现的。 

可预测的停顿：这是G1相对于CMS的另⼀个⼤优势，降低停顿时间是G1 和 CMS 共同的关注点， 但G1 除了追求低停顿外，还能建⽴可预测的停顿时间模型，能让使⽤者明确指定在⼀个⻓度为M 毫秒的时间⽚段内。 

G1收集器的运作⼤致分为以下⼏个步骤： 初始标记 并发标记 最终标记 筛选回收 

G1收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region(这 也就是它的名字Garbage-First的由来)。这种使⽤Region划分内存空间以及有优先级的区域回收⽅式， 保证了GF收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。 